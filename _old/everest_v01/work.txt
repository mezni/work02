Health & Status
GET /health: Service health check (PUBLIC)

Registration & Verification
POST /register: Create new registration (PUBLIC)
POST /verify: Verify registration token (PUBLIC)
POST /verify/resend: Resend verification email (PUBLIC)

Authentication
POST /auth/login: User login (PUBLIC)
POST /auth/logout: User logout (AUTH REQUIRED)
POST /auth/refresh: Refresh tokens (PUBLIC)
POST /auth/validate: Validate token (PUBLIC)

Admin Endpoints
GET /admin/users: List all users (ADMIN AUTH)
GET /admin/users/{id}: Get user by ID (ADMIN AUTH)
POST /admin/users: Create user (ADMIN AUTH)
PUT /admin/users/{id}: Update user (ADMIN AUTH)
DELETE /admin/users/{id}: Delete user (soft delete) (ADMIN AUTH)

Invitations
POST /invitations: Create invitation (ADMIN AUTH)
GET /invitations: List invitations (ADMIN AUTH)
GET /invitations/{code}: Get invitation (PUBLIC)
POST /invitations/{code}/accept: Accept invitation (PUBLIC)
DELETE /invitations/{code}: Cancel invitation (ADMIN AUTH)

Analytics
GET /analytics/registrations: Registration stats (ADMIN AUTH)
GET /analytics/logins: Login statistics (ADMIN AUTH)
GET /analytics/active-users: Active user count (ADMIN AUTH)


Health & Status
GET /health (PUBLIC)

Request

(no body)


Response 200

{
  "status": "ok",
  "db": "up",
  "keycloak": "up",
  "timestamp": "2025-01-01T10:00:00Z"
}

Registration & Verification
POST /register (PUBLIC)

Request

{
  "email": "user@example.com",
  "username": "user1",
  "password": "StrongPassword123!",
  "first_name": "John",
  "last_name": "Doe"
  "phone": "50015001"
}


Response 201

{
  "message": "Registration created. Verification email sent."
}


Errors

409 – email or username already exists

400 – validation error

POST /verify (PUBLIC)

Request

{
  "token": "verification-token-or-code"
}


Response 200

{
  "message": "Account verified and activated."
}


Errors

410 – verification expired

400 – invalid token

POST /verify/resend (PUBLIC)

Request

{
  "email": "user@example.com"
}


Response 200

{
  "message": "Verification email resent."
}


Errors

429 – resend limit exceeded

404 – registration not found

Authentication
POST /auth/login (PUBLIC)

Request

{
  "username": "user1",
  "password": "StrongPassword123!"
}


Response 200

{
  "access_token": "jwt-access-token",
  "refresh_token": "jwt-refresh-token",
  "token_type": "Bearer",
  "expires_in": 300,
  "refresh_expires_in": 1800
}


Errors

401 – invalid credentials

403 – account not verified / disabled

POST /auth/logout (AUTH REQUIRED)

Headers

Authorization: Bearer <access_token>


Request

{
  "refresh_token": "jwt-refresh-token"
}


Response 204

(no body)

POST /auth/refresh (PUBLIC)

Request

{
  "refresh_token": "jwt-refresh-token"
}


Response 200

{
  "access_token": "new-access-token",
  "refresh_token": "new-refresh-token",
  "token_type": "Bearer",
  "expires_in": 300,
  "refresh_expires_in": 1800
}


Errors

401 – invalid or expired refresh token

POST /auth/validate (PUBLIC)

Request

{
  "access_token": "jwt-access-token"
}


Response 200

{
  "active": true,
  "sub": "keycloak-user-id",
  "username": "user1",
  "roles": ["admin"],
  "exp": 1766847942
}


Errors

401 – inactive / invalid token

Admin – User Management (ADMIN AUTH)
GET /admin/users

Response 200

[
  {
    "id": "uuid",
    "email": "user@example.com",
    "username": "user1",
    "status": "active",
    "created_at": "2025-01-01T09:00:00Z"
  }
]

GET /admin/users/{id}

Response 200

{
  "id": "uuid",
  "email": "user@example.com",
  "username": "user1",
  "status": "active",
  "roles": ["user"]
}


Errors

404 – user not found

POST /admin/users

Request

{
  "email": "new@example.com",
  "username": "newuser",
  "password": "TempPass123!",
  "network_id": "NET-ccccccccccccccccc",
  "station_id": "STA-ccccccccccccccccc",
  "roles": "partner"
}


Response 201

{
  "id": "uuid",
  "message": "User created."
}

PUT /admin/users/{id}

Request

{
  "email": "updated@example.com",
  "role": "partner",
  "enabled": true
}


Response 200

{
  "message": "User updated."
}

DELETE /admin/users/{id} (soft delete)

Response 204

(no body)

Invitations
POST /invitations (ADMIN AUTH)

Request

{
  "email": "invitee@example.com",
  "role": "user",
  "expires_in_hours": 72
}


Response 201

{
  "code": "INVITE123",
  "expires_at": "2025-01-04T10:00:00Z"
}

GET /invitations (ADMIN AUTH)

Response 200

[
  {
    "code": "INVITE123",
    "email": "invitee@example.com",
    "status": "pending",
    "expires_at": "2025-01-04T10:00:00Z"
  }
]

GET /invitations/{code} (PUBLIC)

Response 200

{
  "email": "invitee@example.com",
  "role": "user",
  "expires_at": "2025-01-04T10:00:00Z"
}


Errors

404 – invalid code

410 – expired

POST /invitations/{code}/accept (PUBLIC)

Request

{
  "username": "invitee",
  "password": "StrongPassword123!"
}


Response 200

{
  "message": "Invitation accepted. Account created."
}

DELETE /invitations/{code} (ADMIN AUTH)

Response 204

(no body)

Analytics (ADMIN AUTH)
GET /analytics/registrations

Response 200

{
  "total": 1200,
  "pending": 45,
  "verified": 1100,
  "expired": 55
}

GET /analytics/logins

Response 200

{
  "today": 320,
  "last_7_days": 2100,
  "last_30_days": 8200
}

GET /analytics/active-users

Response 200

{
  "active_users": 860
}




ls */*
application/admin_service.rs           core/auth.rs       core/mod.rs             domain/services.rs
application/authentication_service.rs  core/config.rs     core/utils.rs           domain/value_objects.rs
application/health_service.rs          core/constants.rs  domain/entities.rs      infrastructure/keycloak_client.rs
application/invitation_service.rs      core/database.rs   domain/enums.rs         infrastructure/mod.rs
application/mod.rs                     core/errors.rs     domain/mod.rs           presentation/mod.rs
application/registration_service.rs    core/logging.rs    domain/repositories.rs  presentation/openapi.rs

application/dtos:
admin.rs  authentication.rs  health.rs  invitation.rs  mod.rs  registration.rs

infrastructure/repositories:
invitation_repo.rs  mod.rs  registration_repo.rs  user_repo.rs

presentation/controllers:
admin_controller.rs  authentication_controller.rs  health_controller.rs  invitation_controller.rs  mod.rs  registration_controller.rs


sequenceDiagram
    autonumber

    participant C as Client (Frontend)
    participant A as Auth Service (Actix)
    participant K as Keycloak
    participant DB as Service DB
    participant J as Job / Cron

    %% =====================================================
    %% HEALTH
    %% =====================================================
    Note over C,A: Health Check
    C->>A: GET /health
    A->>DB: Ping DB
    DB-->>A: OK
    A-->>C: 200 OK

    %% =====================================================
    %% REGISTRATION
    %% =====================================================
    Note over C,A: Registration
    C->>A: POST /register
    A->>DB: Check email / username uniqueness
    DB-->>A: Not found
    A->>K: Create user (enabled=false, emailVerified=false)
    K-->>A: keycloak_user_id
    A->>DB: Create registration (status=pending, expires_at=+24h)
    A->>K: Send verification email
    A-->>C: 201 Created

    %% =====================================================
    %% EMAIL VERIFICATION (SUCCESS)
    %% =====================================================
    Note over C,A: Email Verification – Success
    C->>A: POST /verify (token)
    A->>DB: Load registration
    DB-->>A: status=pending, not expired
    A->>K: Verify email action
    K-->>A: Email verified
    A->>K: Enable user
    A->>DB: Update status=active
    A-->>C: 200 OK

    %% =====================================================
    %% EMAIL VERIFICATION (EXPIRED)
    %% =====================================================
    Note over C,A: Email Verification – Expired
    C->>A: POST /verify (token)
    A->>DB: Load registration
    DB-->>A: expired
    A->>DB: Update status=verification_expired
    A->>K: Delete user
    A-->>C: 410 Gone

    %% =====================================================
    %% RESEND VERIFICATION
    %% =====================================================
    Note over C,A: Resend Verification
    C->>A: POST /verify/resend
    A->>DB: Check resend limits
    DB-->>A: Allowed
    A->>K: Send verification email
    A->>DB: Update resend count
    A-->>C: 200 OK

    %% =====================================================
    %% LOGIN (VERIFIED USER)
    %% =====================================================
    Note over C,A: Login – Verified User
    C->>A: POST /auth/login
    A->>K: Authenticate (password grant)
    K-->>A: Tokens
    A->>DB: Store session / refresh token
    A-->>C: 200 OK (tokens)

    %% =====================================================
    %% LOGIN (UNVERIFIED USER)
    %% =====================================================
    Note over C,A: Login – Unverified User
    C->>A: POST /auth/login
    A->>K: Authenticate
    K-->>A: User disabled
    A->>DB: Check registration status
    DB-->>A: pending_verification
    A-->>C: 403 Forbidden

    %% =====================================================
    %% TOKEN REFRESH
    %% =====================================================
    Note over C,A: Refresh Token
    C->>A: POST /auth/refresh
    A->>K: Refresh token
    K-->>A: New tokens
    A->>DB: Update session
    A-->>C: 200 OK

    %% =====================================================
    %% LOGOUT
    %% =====================================================
    Note over C,A: Logout
    C->>A: POST /auth/logout
    A->>K: Logout (refresh token)
    A->>DB: Revoke session
    A-->>C: 204 No Content

    %% =====================================================
    %% ADMIN – USER MANAGEMENT
    %% =====================================================
    Note over C,A: Admin User Management
    C->>A: GET /admin/users
    A->>K: Validate token & roles
    K-->>A: admin role OK
    A->>DB: Query users
    DB-->>A: Users list
    A-->>C: 200 OK

    %% =====================================================
    %% INVITATIONS
    %% =====================================================
    Note over C,A: Create Invitation
    C->>A: POST /invitations
    A->>DB: Store invitation (expires_at)
    A-->>C: 201 Created

    Note over C,A: Accept Invitation
    C->>A: POST /invitations/{code}/accept
    A->>DB: Validate invitation
    DB-->>A: Valid
    A->>K: Create user / assign roles
    A->>DB: Mark invitation accepted
    A-->>C: 200 OK

    %% =====================================================
    %% ANALYTICS
    %% =====================================================
    Note over C,A: Analytics
    C->>A: GET /analytics/*
    A->>DB: Aggregate stats
    DB-->>A: Results
    A-->>C: 200 OK

    %% =====================================================
    %% CRON / CLEANUP
    %% =====================================================
    Note over J,A: Cleanup Job
    J->>A: Expired registrations cleanup
    A->>DB: Find expired
    A->>K: Delete users
    A->>DB: Update statuses

actix-cors = "0.7.1"
actix-web = "4.12.1"
anyhow = "1.0.100"
async-trait = "0.1.89"
chrono = { version = "0.4.42", features = ["serde"] }
dotenvy = "0.15.7"
nanoid = "0.4.0"
reqwest = { version = "0.12.26", features = ["json", "rustls-tls"] }
serde = { version = "1.0.228", features = ["derive"] }
serde_json = "1.0.145"
sqlx = { version = "0.8.6", features = ["chrono", "macros", "postgres", "runtime-tokio-rustls"] }
thiserror = "2.0.17"
tokio = { version = "1.48.0", features = ["full"] }
tracing = "0.1.44"
tracing-actix-web = "0.7.20"
tracing-subscriber = { version = "0.3.22", features = ["env-filter"] }
utoipa = { version = "5.4.0", features = ["actix_extras", "chrono"] }
utoipa-swagger-ui = { version = "9.0.2", features = ["actix-web"] }
validator = { version = "0.20.0", features = ["derive"] }


HOST=127.0.0.1
PORT=3000
DATABASE_URL=postgresql://postgres:password@localhost:5800/auth_db
# Options: error, warn, info, debug, trace
RUST_LOG=debug


# Keycloak Configuration
KEYCLOAK_URL=http://localhost:5080
KEYCLOAK_REALM=myrealm

# Frontend client (public, for user authentication)
KEYCLOAK_AUTH_CLIENT_ID=auth-client

# Backend service account (confidential, for admin operations)
KEYCLOAK_BACKEND_CLIENT_ID=backend-admin
KEYCLOAK_BACKEND_CLIENT_SECRET=backend-admin-secret



{
  "exp": 1766847942,
  "iat": 1766847642,
  "jti": "onrtro:fa971d59-122b-53ec-4623-c88e23ded07f",
  "iss": "http://localhost:5080/realms/myrealm",
  "aud": "account",
  "sub": "c7d27ad3-3876-41b2-b13f-3e0beda4b21c",
  "typ": "Bearer",
  "azp": "auth-client",
  "sid": "956862b4-5985-3143-08dd-4ce23abd56fd",
  "acr": "1",
  "allowed-origins": [
    "http://localhost:8081"
  ],
  "realm_access": {
    "roles": [
      "default-roles-myrealm",
      "offline_access",
      "admin",
      "uma_authorization"
    ]
  },
  "resource_access": {
    "account": {
      "roles": [
        "manage-account",
        "manage-account-links",
        "view-profile"
      ]
    }
  },
  "scope": "openid profile email",
  "email_verified": true,
  "roles": [
    "default-roles-myrealm",
    "offline_access",
    "admin",
    "uma_authorization"
  ],
  "preferred_username": "system",
  "email": "system@example.com"
}


use anyhow::Context;
use auth_service::core::{config::Config, logging};

#[actix_web::main]
async fn main() -> anyhow::Result<()> {
    let config = Config::from_env();
    logging::init_logging(&config.log_level);

    auth_service::run()
        .await
        .context("Application server crashed")?;

    Ok(())
}


use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use tokio::sync::RwLock;

// ============================================================================
// Errors & Results
// ============================================================================

#[derive(Debug)]
pub enum AppError {
    KeycloakError(String),
    NetworkError(String),
    AuthenticationError(String),
    NotFound(String),
    Unauthorized(String),
}

impl std::fmt::Display for AppError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::KeycloakError(m) => write!(f, "Keycloak: {}", m),
            Self::NetworkError(m) => write!(f, "Network: {}", m),
            Self::AuthenticationError(m) => write!(f, "Auth: {}", m),
            Self::NotFound(m) => write!(f, "Not Found: {}", m),
            Self::Unauthorized(m) => write!(f, "Unauthorized: {}", m),
        }
    }
}

impl std::error::Error for AppError {}
pub type AppResult<T> = Result<T, AppError>;

// ============================================================================
// Models
// ============================================================================

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TokenResponse {
    pub access_token: String,
    pub refresh_token: String,
    pub token_type: String,
    pub expires_in: i64,
    pub refresh_expires_in: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct KeycloakUser {
    pub id: String,
    pub username: String,
    pub email: String,
    pub enabled: bool,
    pub attributes: Option<HashMap<String, Vec<String>>>,
}

#[derive(Debug, Serialize)]
struct CreateUserRequest {
    pub username: String,
    pub email: String,
    pub enabled: bool,
    #[serde(rename = "emailVerified")]
    pub email_verified: bool,
    pub credentials: Vec<Credential>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attributes: Option<HashMap<String, Vec<String>>>,
}

#[derive(Debug, Serialize, Deserialize)]
struct Credential {
    #[serde(rename = "type")]
    pub kind: String,
    pub value: String,
    pub temporary: bool,
}

#[derive(Debug, Serialize, Deserialize)]
struct RoleMapping {
    pub id: String,
    pub name: String,
}

// ============================================================================
// Trait Definition
// ============================================================================

#[async_trait]
pub trait KeycloakClient: Send + Sync {
    async fn create_user(
        &self,
        email: &str,
        username: &str,
        password: &str,
        attributes: Option<HashMap<String, Vec<String>>>,
    ) -> AppResult<String>;
    async fn get_user(&self, user_id: &str) -> AppResult<KeycloakUser>;
    async fn enable_user(&self, user_id: &str) -> AppResult<()>;
    async fn disable_user(&self, user_id: &str) -> AppResult<()>;
    async fn assign_role(&self, user_id: &str, role_name: &str) -> AppResult<()>;
    async fn authenticate(&self, username: &str, password: &str) -> AppResult<TokenResponse>;
    async fn refresh_token(&self, refresh_token: &str) -> AppResult<TokenResponse>;
    async fn logout(&self, refresh_token: &str) -> AppResult<()>;
    async fn verify_token(&self, access_token: &str) -> AppResult<serde_json::Value>;
    async fn get_user_info(&self, access_token: &str) -> AppResult<serde_json::Value>;
    async fn send_verification_email(&self, keycloak_id: &str) -> AppResult<()>;
}

// ============================================================================
// Implementation
// ============================================================================

pub struct HttpKeycloakClient {
    base_url: String, // e.g., "http://localhost:8080"
    realm: String,
    backend_id: String,
    backend_secret: String,
    auth_id: String,
    http: reqwest::Client,
    admin_token_cache: RwLock<Option<AdminToken>>,
}

#[derive(Clone)]
struct AdminToken {
    token: String,
    expires_at: chrono::DateTime<chrono::Utc>,
}

impl HttpKeycloakClient {
    pub fn new(
        base_url: String,
        realm: String,
        backend_id: String,
        backend_secret: String,
        auth_id: String,
    ) -> Self {
        Self {
            base_url: base_url.trim_end_matches('/').to_string(),
            realm,
            backend_id,
            backend_secret,
            auth_id,
            http: reqwest::Client::new(),
            admin_token_cache: RwLock::new(None),
        }
    }

    // --- URL Helper Methods (Inspired by your code) ---

    fn auth_url(&self) -> String {
        format!(
            "{}/realms/{}/protocol/openid-connect",
            self.base_url, self.realm
        )
    }

    fn admin_url(&self) -> String {
        format!("{}/admin/realms/{}", self.base_url, self.realm)
    }

    fn token_endpoint(&self) -> String {
        format!("{}/token", self.auth_url())
    }

    fn user_endpoint(&self, user_id: &str) -> String {
        format!("{}/users/{}", self.admin_url(), user_id)
    }

    fn role_endpoint(&self, role_name: &str) -> String {
        format!("{}/roles/{}", self.admin_url(), role_name)
    }

    async fn get_admin_token(&self) -> AppResult<String> {
        {
            let cache = self.admin_token_cache.read().await;
            if let Some(ref t) = *cache {
                if chrono::Utc::now() < t.expires_at {
                    return Ok(t.token.clone());
                }
            }
        }

        let params = [
            ("grant_type", "client_credentials"),
            ("client_id", self.backend_id.as_str()),
            ("client_secret", self.backend_secret.as_str()),
        ];

        let resp = self
            .http
            .post(self.token_endpoint())
            .form(&params)
            .send()
            .await
            .map_err(|e| AppError::NetworkError(e.to_string()))?;

        if !resp.status().is_success() {
            let body = resp.text().await.unwrap_or_default();
            return Err(AppError::AuthenticationError(format!(
                "Admin login failed: {}",
                body
            )));
        }

        let data: serde_json::Value = resp
            .json()
            .await
            .map_err(|e| AppError::NetworkError(e.to_string()))?;
        let token = data["access_token"]
            .as_str()
            .ok_or(AppError::AuthenticationError("No access token".into()))?
            .to_string();
        let expires_in = data["expires_in"].as_i64().unwrap_or(300);

        let mut cache = self.admin_token_cache.write().await;
        *cache = Some(AdminToken {
            token: token.clone(),
            expires_at: chrono::Utc::now() + chrono::Duration::seconds(expires_in - 20),
        });

        Ok(token)
    }
}

#[async_trait]
impl KeycloakClient for HttpKeycloakClient {
    async fn create_user(
        &self,
        email: &str,
        username: &str,
        password: &str,
        attributes: Option<HashMap<String, Vec<String>>>,
    ) -> AppResult<String> {
        let token = self.get_admin_token().await?;
        let body = CreateUserRequest {
            username: username.to_string(),
            email: email.to_string(),
            enabled: true,
            email_verified: true,
            credentials: vec![Credential {
                kind: "password".into(),
                value: password.into(),
                temporary: false,
            }],
            attributes,
        };

        let url = format!("{}/users", self.admin_url());
        let resp = self
            .http
            .post(url)
            .bearer_auth(token)
            .json(&body)
            .send()
            .await
            .map_err(|e| AppError::NetworkError(e.to_string()))?;

        if !resp.status().is_success() {
            return Err(AppError::KeycloakError(
                resp.text().await.unwrap_or_default(),
            ));
        }

        let loc = resp
            .headers()
            .get("Location")
            .and_then(|l| l.to_str().ok())
            .ok_or(AppError::KeycloakError(
                "No user ID in Location header".into(),
            ))?;
        Ok(loc.split('/').last().unwrap_or_default().to_string())
    }

    async fn get_user(&self, user_id: &str) -> AppResult<KeycloakUser> {
        let token = self.get_admin_token().await?;
        let resp = self
            .http
            .get(self.user_endpoint(user_id))
            .bearer_auth(token)
            .send()
            .await
            .map_err(|e| AppError::NetworkError(e.to_string()))?;

        if resp.status() == 404 {
            return Err(AppError::NotFound("User not found".into()));
        }
        resp.json::<KeycloakUser>()
            .await
            .map_err(|e| AppError::NetworkError(e.to_string()))
    }

    async fn enable_user(&self, user_id: &str) -> AppResult<()> {
        let token = self.get_admin_token().await?;
        let mut body = HashMap::new();
        body.insert("enabled", true);

        let resp = self
            .http
            .put(self.user_endpoint(user_id))
            .bearer_auth(token)
            .json(&body)
            .send()
            .await
            .map_err(|e| AppError::NetworkError(e.to_string()))?;

        if !resp.status().is_success() {
            return Err(AppError::KeycloakError(
                resp.text().await.unwrap_or_default(),
            ));
        }
        Ok(())
    }

    async fn disable_user(&self, user_id: &str) -> AppResult<()> {
        let token = self.get_admin_token().await?;
        let mut body = HashMap::new();
        body.insert("enabled", false);

        let resp = self
            .http
            .put(self.user_endpoint(user_id))
            .bearer_auth(token)
            .json(&body)
            .send()
            .await
            .map_err(|e| AppError::NetworkError(e.to_string()))?;

        if !resp.status().is_success() {
            return Err(AppError::KeycloakError(
                resp.text().await.unwrap_or_default(),
            ));
        }
        Ok(())
    }

    async fn assign_role(&self, user_id: &str, role_name: &str) -> AppResult<()> {
        let token = self.get_admin_token().await?;

        let role_resp = self
            .http
            .get(self.role_endpoint(role_name))
            .bearer_auth(&token)
            .send()
            .await
            .map_err(|e| AppError::NetworkError(e.to_string()))?;

        if !role_resp.status().is_success() {
            let body = role_resp.text().await.unwrap_or_default();
            return Err(AppError::NotFound(format!(
                "Role {} lookup failed: {}",
                role_name, body
            )));
        }

        let role_data: RoleMapping = role_resp
            .json()
            .await
            .map_err(|e| AppError::NetworkError(e.to_string()))?;
        let mapping_url = format!("{}/role-mappings/realm", self.user_endpoint(user_id));

        let resp = self
            .http
            .post(mapping_url)
            .bearer_auth(token)
            .json(&vec![role_data])
            .send()
            .await
            .map_err(|e| AppError::NetworkError(e.to_string()))?;

        if !resp.status().is_success() {
            return Err(AppError::KeycloakError(
                resp.text().await.unwrap_or_default(),
            ));
        }
        Ok(())
    }

    async fn authenticate(&self, username: &str, password: &str) -> AppResult<TokenResponse> {
        let params = [
            ("grant_type", "password"),
            ("client_id", self.auth_id.as_str()),
            ("username", username),
            ("password", password),
            ("scope", "openid"),
        ];

        let resp = self
            .http
            .post(self.token_endpoint())
            .form(&params)
            .send()
            .await
            .map_err(|e| AppError::NetworkError(e.to_string()))?;

        if !resp.status().is_success() {
            let status = resp.status();
            let error_body = resp.text().await.unwrap_or_default();

            // Log this to your server console so you can see it
            eprintln!(
                "Keycloak Auth Failed | Status: {} | Body: {}",
                status, error_body
            );

            return Err(AppError::AuthenticationError(format!(
                "Login failed ({}): {}",
                status, error_body
            )));
        }

        resp.json::<TokenResponse>()
            .await
            .map_err(|e| AppError::NetworkError(e.to_string()))
    }

    async fn refresh_token(&self, refresh_token: &str) -> AppResult<TokenResponse> {
        let params = [
            ("grant_type", "refresh_token"),
            ("client_id", self.auth_id.as_str()),
            ("refresh_token", refresh_token),
        ];

        let resp = self
            .http
            .post(self.token_endpoint())
            .form(&params)
            .send()
            .await
            .map_err(|e| AppError::NetworkError(e.to_string()))?;

        if !resp.status().is_success() {
            return Err(AppError::Unauthorized("Refresh failed".into()));
        }
        resp.json::<TokenResponse>()
            .await
            .map_err(|e| AppError::NetworkError(e.to_string()))
    }

    async fn logout(&self, refresh_token: &str) -> AppResult<()> {
        let url = format!("{}/logout", self.auth_url());
        let params = [
            ("client_id", self.auth_id.as_str()),
            ("refresh_token", refresh_token),
        ];
        let _ = self.http.post(url).form(&params).send().await;
        Ok(())
    }

    async fn verify_token(&self, access_token: &str) -> AppResult<serde_json::Value> {
        let url = format!("{}/token/introspect", self.auth_url());
        let params = [
            ("token", access_token),
            ("client_id", self.auth_id.as_str()),
        ];

        let resp = self
            .http
            .post(url)
            .form(&params)
            .send()
            .await
            .map_err(|e| AppError::NetworkError(e.to_string()))?;
        let data: serde_json::Value = resp
            .json()
            .await
            .map_err(|e| AppError::NetworkError(e.to_string()))?;

        if data["active"].as_bool() == Some(true) {
            Ok(data)
        } else {
            Err(AppError::Unauthorized("Inactive token".into()))
        }
    }

    async fn get_user_info(&self, access_token: &str) -> AppResult<serde_json::Value> {
        let url = format!("{}/userinfo", self.auth_url());
        let resp = self
            .http
            .get(url)
            .bearer_auth(access_token)
            .send()
            .await
            .map_err(|e| AppError::NetworkError(e.to_string()))?;

        if !resp.status().is_success() {
            return Err(AppError::Unauthorized("Invalid token".into()));
        }
        resp.json()
            .await
            .map_err(|e| AppError::NetworkError(e.to_string()))
    }

    async fn send_verification_email(&self, keycloak_id: &str) -> AppResult<()> {
        let token = self.get_admin_token().await?;

        // Keycloak Admin API endpoint to trigger specific actions (like email verification)
        let url = format!("{}/execute-actions-email", self.user_endpoint(keycloak_id));

        // We send a PUT request with the action we want the user to perform
        let actions = vec!["VERIFY_EMAIL"];

        let resp = self
            .http
            .put(url)
            .bearer_auth(token)
            .json(&actions)
            .send()
            .await
            .map_err(|e| AppError::NetworkError(e.to_string()))?;

        if !resp.status().is_success() {
            let body = resp.text().await.unwrap_or_default();
            return Err(AppError::KeycloakError(format!(
                "Failed to send email: {}",
                body
            )));
        }

        Ok(())
    }
}




use app_state and pass it to controllers 


ids are generated XXX-nanoid(16) example for users should be USR-nanoid(16)

use core/constants.rs for all constants

admin user can create other users with role admin or partner or operator 
self registred users are given a default role user , and source = web and network_id='X' and station_id='X'
when creating users in keycloak we should add attributes network_id and station_id and give it the role assigned to it



main.rs 
use anyhow::Context;
use auth_service::core::{config::Config, logging};

#[actix_web::main]
async fn main() -> anyhow::Result<()> {
    let config = Config::from_env();
    logging::init_logging(&config.log_level);

    auth_service::run()
        .await
        .context("Application server crashed")?;

    Ok(())
}


domain/repositories.rs
use super::entities::{Invitation, User, UserRegistration};
use crate::core::errors::AppResult;
use async_trait::async_trait;

#[async_trait]
pub trait UserRepository: Send + Sync {
    async fn create(&self, user: &User) -> AppResult<User>;
    async fn find_by_id(&self, user_id: &str) -> AppResult<Option<User>>;
    async fn find_by_email(&self, email: &str) -> AppResult<Option<User>>;
    async fn find_by_keycloak_id(&self, keycloak_id: &str) -> AppResult<Option<User>>;
    async fn update(&self, user: &User) -> AppResult<User>;
    async fn update_last_login(&self, user_id: &str) -> AppResult<()>;

    // Add these two methods for Admin pagination
    async fn list_active(&self, limit: i64, offset: i64) -> AppResult<Vec<User>>;
    async fn count_active(&self, network_id: Option<&str>) -> AppResult<i64>;
}

#[async_trait]
pub trait RegistrationRepository: Send + Sync {
    async fn create(&self, registration: &UserRegistration) -> AppResult<UserRegistration>;
    async fn find_by_id(&self, registration_id: &str) -> AppResult<Option<UserRegistration>>;
    async fn find_by_email(&self, email: &str) -> AppResult<Option<UserRegistration>>;
    async fn find_by_token(&self, token: &str) -> AppResult<Option<UserRegistration>>;
    async fn update(&self, registration: &UserRegistration) -> AppResult<UserRegistration>;
}

#[async_trait]
pub trait InvitationRepository: Send + Sync {
    async fn create(&self, invitation: &Invitation) -> AppResult<Invitation>;
    async fn find_by_id(&self, invitation_id: &str) -> AppResult<Option<Invitation>>;
    async fn find_by_code(&self, code: &str) -> AppResult<Option<Invitation>>;
    async fn find_by_email(&self, email: &str) -> AppResult<Vec<Invitation>>;
    async fn list(&self, limit: i64, offset: i64) -> AppResult<Vec<Invitation>>;
    async fn update(&self, invitation: &Invitation) -> AppResult<Invitation>;
    async fn delete(&self, invitation_id: &str) -> AppResult<()>;
}


domain/services.rs 
use crate::core::errors::AppResult;
use crate::domain::entities::{Invitation, User, UserRegistration};
use crate::domain::enums::{Source, UserRole};
use async_trait::async_trait;

#[async_trait]
pub trait RegistrationService: Send + Sync {
    async fn register(
        &self,
        email: String,
        username: String,
        password: String,
        first_name: Option<String>,
        last_name: Option<String>,
        phone: Option<String>,
        source: Source,
        ip_address: Option<String>,
        user_agent: Option<String>,
    ) -> AppResult<UserRegistration>;

    // Matches implementation: Returns User
    async fn verify(&self, email: String, token: String) -> AppResult<User>;

    // Matches implementation: Returns ()
    async fn resend_verification(&self, email: String) -> AppResult<()>;
}
#[async_trait]
pub trait AuthenticationService: Send + Sync {
    async fn login(&self, username: String, password: String) -> AppResult<LoginResponse>;
    async fn logout(&self, refresh_token: String) -> AppResult<()>;
    async fn refresh_token(&self, refresh_token: String) -> AppResult<LoginResponse>;
}

#[async_trait]
pub trait AdminService: Send + Sync {
    async fn list_users(&self, limit: i64, offset: i64) -> AppResult<(Vec<User>, i64)>;
    async fn get_user(&self, user_id: &str) -> AppResult<User>;
    async fn create_user(&self, user_data: CreateUserData) -> AppResult<User>;
    async fn update_user(&self, user_id: &str, user_data: UpdateUserData) -> AppResult<User>;
    async fn delete_user(&self, user_id: &str) -> AppResult<()>;
}

#[async_trait]
pub trait InvitationService: Send + Sync {
    async fn create_invitation(
        &self,
        email: String,
        role: String,
        invited_by: String,
        expires_in_hours: i64,
        metadata: Option<serde_json::Value>,
    ) -> AppResult<Invitation>;

    async fn list_invitations(&self, limit: i64, offset: i64) -> AppResult<Vec<Invitation>>;
    async fn get_invitation(&self, code: String) -> AppResult<Invitation>;
    async fn accept_invitation(&self, code: String, password: String) -> AppResult<User>;
    async fn cancel_invitation(&self, code: String) -> AppResult<()>;
}


generate full code for me begin by presentation and core layers then application , domain , repositories, db schema , maib.rs , lib.rs , job 