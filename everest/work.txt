D
ay 4: Health Checks

Step 4.1: Implement Health Endpoints
rust

// configurator-service/src/health.rs
use actix_web::{get, web, HttpResponse, Responder};
use serde::Serialize;
use sqlx::{PgPool, Row};
use utoipa::ToSchema;

#[derive(Serialize, ToSchema)]
pub struct HealthStatus {
    pub status: String,
    pub timestamp: String,
}

#[derive(Serialize, ToSchema)]
pub struct ReadinessStatus {
    pub status: String,
    pub database: String,
    pub timestamp: String,
}

#[utoipa::path(
    get,
    path = "/health",
    responses(
        (status = 200, description = "Service is healthy", body = HealthStatus)
    ),
    tag = "health"
)]
#[get("/health")]
pub async fn health_check() -> impl Responder {
    HttpResponse::Ok().json(HealthStatus {
        status: "healthy".to_string(),
        timestamp: chrono::Utc::now().to_rfc3339(),
    })
}

#[utoipa::path(
    get,
    path = "/ready",
    responses(
        (status = 200, description = "Service is ready", body = ReadinessStatus),
        (status = 503, description = "Service is not ready", body = ReadinessStatus)
    ),
    tag = "health"
)]
#[get("/ready")]
pub async fn readiness_check(pool: web::Data<PgPool>) -> impl Responder {
    let timestamp = chrono::Utc::now().to_rfc3339();
    
    match sqlx::query("SELECT 1").execute(pool.get_ref()).await {
        Ok(_) => HttpResponse::Ok().json(ReadinessStatus {
            status: "ready".to_string(),
            database: "connected".to_string(),
            timestamp,
        }),
        Err(_) => HttpResponse::ServiceUnavailable().json(ReadinessStatus {
            status: "not_ready".to_string(), 
            database: "disconnected".to_string(),
            timestamp,
        })
    }
}

pub fn configure(cfg: &mut web::ServiceConfig) {
    cfg.service(health_check)
        .service(readiness_check);
}

ep 5.1: Create API Module Structure
rust

// configurator-service/src/api/mod.rs
use actix_web::web;

pub mod organizations;
pub mod docs;

pub fn configure(cfg: &mut web::ServiceConfig) {
    cfg.service(
        web::scope("/api")
            .configure(organizations::configure)
            .configure(docs::configure)
    );
}

Step 5.2: Implement Organizations API
rust

// configurator-service/src/api/organizations.rs
use actix_web::{web, HttpResponse};
use serde::Deserialize;
use sqlx::{PgPool, Row};
use utoipa::ToSchema;
use uuid::Uuid;

#[derive(Debug, Deserialize, ToSchema)]
pub struct CreateOrganizationRequest {
    pub name: String,
}

#[derive(Debug, serde::Serialize, ToSchema)]
pub struct OrganizationResponse {
    pub id: String,
    pub name: String,
    pub status: String,
    pub created_at: String,
}

/// Create a new organization
#[utoipa::path(
    post,
    path = "/api/organizations",
    request_body = CreateOrganizationRequest,
    responses(
        (status = 201, description = "Organization created successfully", body = OrganizationResponse),
        (status = 400, description = "Invalid input data"),
        (status = 500, description = "Internal server error")
    ),
    tag = "organizations"
)]
pub async fn create_organization(
    pool: web::Data<PgPool>,
    request: web::Json<CreateOrganizationRequest>,
) -> HttpResponse {
    let system_user_id = Uuid::parse_str("00000000-0000-0000-0000-000000000001").unwrap();
    
    match sqlx::query(
        r#"
        INSERT INTO organizations (name, created_by, updated_by)
        VALUES ($1, $2, $3)
        RETURNING id, name, status, created_at
        "#,
    )
    .bind(&request.name)
    .bind(system_user_id)
    .bind(system_user_id)
    .fetch_one(pool.get_ref())
    .await {
        Ok(row) => {
            let id: Uuid = row.get("id");
            let name: String = row.get("name");
            let status: String = row.get("status");
            let created_at: chrono::DateTime<chrono::Utc> = row.get("created_at");
            
            HttpResponse::Created().json(OrganizationResponse {
                id: id.to_string(),
                name,
                status,
                created_at: created_at.to_rfc3339(),
            })
        }
        Err(e) => {
            eprintln!("Failed to create organization: {}", e);
            HttpResponse::InternalServerError().json(serde_json::json!({
                "error": "Failed to create organization"
            }))
        }
    }
}

pub fn configure(cfg: &mut web::ServiceConfig) {
    cfg.service(
        web::resource("/organizations")
            .route(web::post().to(create_organization))
    );
}

Step 5.3: Implement OpenAPI Documentation
rust

// configurator-service/src/api/docs.rs
use actix_web::web;
use utoipa::OpenApi;
use utoipa_swagger_ui::SwaggerUi;

use crate::health::{HealthStatus, ReadinessStatus};
use crate::api::organizations::{CreateOrganizationRequest, OrganizationResponse};

#[derive(OpenApi)]
#[openapi(
    info(
        title = "EV Charging Configurator API",
        version = "1.0.0",
        description = "API for managing EV charging stations, organizations, and users"
    ),
    paths(
        crate::health::health_check,
        crate::health::readiness_check,
        crate::api::organizations::create_organization,
    ),
    components(
        schemas(
            HealthStatus,
            ReadinessStatus,
            CreateOrganizationRequest,
            OrganizationResponse
        )
    ),
    tags(
        (name = "Health", description = "Health check endpoints"),
        (name = "Organizations", description = "Organization management endpoints")
    )
)]
struct ApiDoc;

pub fn configure(cfg: &mut web::ServiceConfig) {
    cfg.service(
        SwaggerUi::new("/docs/{_:.*}")
            .url("/api-docs/openapi.json", ApiDoc::openapi())
    );
}

PHASE 2: DATABASE & DOMAIN (Week 2)
Day 6-7: Database Migrations

Step 6.1: Create Database Migrations
sql

-- configurator-service/migrations/001_initial.sql
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

CREATE TABLE organizations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(255) NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'active',
    created_by UUID NOT NULL,
    updated_by UUID NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email VARCHAR(255) UNIQUE NOT NULL,
    display_name VARCHAR(255) NOT NULL,
    role VARCHAR(50) NOT NULL,
    organization_id UUID REFERENCES organizations(id),
    station_id UUID,
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    created_by UUID NOT NULL,
    updated_by UUID NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE TABLE stations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(255) NOT NULL,
    location JSONB,
    organization_id UUID NOT NULL REFERENCES organizations(id),
    status VARCHAR(50) NOT NULL DEFAULT 'active',
    created_by UUID NOT NULL,
    updated_by UUID NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Create indexes
CREATE INDEX idx_users_organization_id ON users(organization_id);
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_stations_organization_id ON stations(organization_id);

-- Insert default system data
INSERT INTO organizations (id, name, created_by, updated_by) VALUES 
('00000000-0000-0000-0000-000000000001', 'System Administration', '00000000-0000-0000-0000-000000000001', '00000000-0000-0000-0000-000000000001');

INSERT INTO users (id, email, display_name, role, organization_id, created_by, updated_by, status) VALUES 
('00000000-0000-0000-0000-000000000001', 'admin@evcharging.com', 'System Administrator', 'super_admin', '00000000-0000-0000-0000-000000000001', '00000000-0000-0000-0000-000000000001', '00000000-0000-0000-0000-000000000001', 'active');

Day 8-9: Domain Models

Step 8.1: Create Domain Types
rust

// configurator-service/src/domain/mod.rs
pub mod types;
pub mod user;
pub mod organization;

// configurator-service/src/domain/types.rs
use serde::{Deserialize, Serialize};
use uuid::Uuid;

pub type UserId = Uuid;
pub type OrganizationId = Uuid;
pub type StationId = Uuid;

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum UserRole {
    SuperAdmin,
    Partner,
    Operator,
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum UserStatus {
    Pending,
    Active,
    Inactive,
    Deleted,
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum OrganizationStatus {
    Active,
    Inactive,
}

#[derive(Debug, Clone)]
pub struct AuditInfo {
    pub created_by: UserId,
    pub updated_by: UserId,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

impl AuditInfo {
    pub fn new(created_by: UserId) -> Self {
        let now = chrono::Utc::now();
        Self {
            created_by,
            updated_by: created_by,
            created_at: now,
            updated_at: now,
        }
    }
}

Step 8.2: Create User Domain Model
rust

// configurator-service/src/domain/user.rs
use super::types::{UserId, OrganizationId, StationId, UserRole, UserStatus, AuditInfo};

#[derive(Debug, Clone)]
pub struct User {
    pub id: UserId,
    pub email: String,
    pub display_name: String,
    pub role: UserRole,
    pub organization_id: Option<OrganizationId>,
    pub station_id: Option<StationId>,
    pub status: UserStatus,
    pub audit: AuditInfo,
}

impl User {
    pub fn new(
        email: String,
        display_name: String,
        role: UserRole,
        organization_id: Option<OrganizationId>,
        station_id: Option<StationId>,
        created_by: UserId,
    ) -> Result<Self, String> {
        // Validate business rules
        if let Err(e) = Self::validate_creation(&role, organization_id, station_id) {
            return Err(e);
        }
        
        Ok(Self {
            id: UserId::new_v4(),
            email,
            display_name,
            role,
            organization_id,
            station_id,
            status: UserStatus::Pending,
            audit: AuditInfo::new(created_by),
        })
    }
    
    fn validate_creation(
        role: &UserRole,
        organization_id: Option<OrganizationId>,
        station_id: Option<StationId>,
    ) -> Result<(), String> {
        match role {
            UserRole::SuperAdmin => {
                if organization_id.is_some() || station_id.is_some() {
                    return Err("Super admin cannot have organization or station".to_string());
                }
            }
            UserRole::Partner => {
                if organization_id.is_none() {
                    return Err("Partner must have an organization".to_string());
                }
                if station_id.is_some() {
                    return Err("Partner cannot have a station".to_string());
                }
            }
            UserRole::Operator => {
                if organization_id.is_none() || station_id.is_none() {
                    return Err("Operator must have both organization and station".to_string());
                }
            }
        }
        Ok(())
    }
    
    pub fn activate(&mut self, updated_by: UserId) {
        self.status = UserStatus::Active;
        self.audit.updated_by = updated_by;
        self.audit.updated_at = chrono::Utc::now();
    }
    
    pub fn deactivate(&mut self, updated_by: UserId) {
        self.status = UserStatus::Inactive;
        self.audit.updated_by = updated_by;
        self.audit.updated_at = chrono::Utc::now();
    }
}

Day 10: Repository Pattern

Step 10.1: Create Repository Traits
rust

// configurator-service/src/domain/repositories.rs
use async_trait::async_trait;
use super::user::User;
use super::types::{UserId, OrganizationId};

#[async_trait]
pub trait UserRepository: Send + Sync {
    async fn find_by_id(&self, id: UserId) -> Result<User, String>;
    async fn save(&self, user: User) -> Result<(), String>;
    async fn find_by_organization(&self, org_id: OrganizationId) -> Result<Vec<User>, String>;
}

#[async_trait]
pub trait OrganizationRepository: Send + Sync {
    async fn find_by_id(&self, id: OrganizationId) -> Result<super::organization::Organization, String>;
    async fn save(&self, org: super::organization::Organization) -> Result<(), String>;
    async fn list_all(&self) -> Result<Vec<super::organization::Organization>, String>;
}

Step 10.2: Implement SQLx Repositories
rust

// configurator-service/src/infrastructure/repositories/user_repository.rs
use async_trait::async_trait;
use sqlx::PgPool;
use crate::domain::repositories::UserRepository;
use crate::domain::user::User;
use crate::domain::types::{UserId, OrganizationId, UserRole, UserStatus, AuditInfo};

pub struct UserRepositoryImpl {
    pool: PgPool,
}

impl UserRepositoryImpl {
    pub fn new(pool: PgPool) -> Self {
        Self { pool }
    }
}

#[async_trait]
impl UserRepository for UserRepositoryImpl {
    async fn find_by_id(&self, id: UserId) -> Result<User, String> {
        let record = sqlx::query!(
            r#"
            SELECT id, email, display_name, role, organization_id, station_id, status,
                   created_by, updated_by, created_at, updated_at
            FROM users 
            WHERE id = $1
            "#,
            id
        )
        .fetch_one(&self.pool)
        .await
        .map_err(|e| e.to_string())?;
        
        // Convert database record to domain model
        Ok(User {
            id: record.id,
            email: record.email,
            display_name: record.display_name,
            role: match record.role.as_str() {
                "super_admin" => UserRole::SuperAdmin,
                "partner" => UserRole::Partner,
                "operator" => UserRole::Operator,
                _ => return Err("Invalid user role".to_string()),
            },
            organization_id: record.organization_id,
            station_id: record.station_id,
            status: match record.status.as_str() {
                "pending" => UserStatus::Pending,
                "active" => UserStatus::Active,
                "inactive" => UserStatus::Inactive,
                "deleted" => UserStatus::Deleted,
                _ => return Err("Invalid user status".to_string()),
            },
            audit: AuditInfo {
                created_by: record.created_by,
                updated_by: record.updated_by,
                created_at: record.created_at,
                updated_at: record.updated_at,
            },
        })
    }
    
    async fn save(&self, user: User) -> Result<(), String> {
        let role_str = match user.role {
            UserRole::SuperAdmin => "super_admin",
            UserRole::Partner => "partner",
            UserRole::Operator => "operator",
        };
        
        let status_str = match user.status {
            UserStatus::Pending => "pending",
            UserStatus::Active => "active",
            UserStatus::Inactive => "inactive",
            UserStatus::Deleted => "deleted",
        };
        
        sqlx::query!(
            r#"
            INSERT INTO users (id, email, display_name, role, organization_id, station_id, status,
                             created_by, updated_by, created_at, updated_at)
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
            ON CONFLICT (id) DO UPDATE SET
                email = $2, display_name = $3, role = $4, organization_id = $5,
                station_id = $6, status = $7, updated_by = $9, updated_at = $11
            "#,
            user.id,
            user.email,
            user.display_name,
            role_str,
            user.organization_id,
            user.station_id,
            status_str,
            user.audit.created_by,
            user.audit.updated_by,
            user.audit.created_at,
            user.audit.updated_at,
        )
        .execute(&self.pool)
        .await
        .map_err(|e| e.to_string())?;
        
        Ok(())
    }
    
    async fn find_by_organization(&self, org_id: OrganizationId) -> Result<Vec<User>, String> {
        let records = sqlx::query!(
            r#"
            SELECT id, email, display_name, role, organization_id, station_id, status,
                   created_by, updated_by, created_at, updated_at
            FROM users 
            WHERE organization_id = $1 AND status != 'deleted'
            "#,
            org_id
        )
        .fetch_all(&self.pool)
        .await
        .map_err(|e| e.to_string())?;
        
        let mut users = Vec::new();
        for record in records {
            users.push(User {
                id: record.id,
                email: record.email,
                display_name: record.display_name,
                role: match record.role.as_str() {
                    "super_admin" => UserRole::SuperAdmin,
                    "partner" => UserRole::Partner,
                    "operator" => UserRole::Operator,
                    _ => return Err("Invalid user role".to_string()),
                },
                organization_id: record.organization_id,
                station_id: record.station_id,
                status: match record.status.as_str() {
                    "pending" => UserStatus::Pending,
                    "active" => UserStatus::Active,
                    "inactive" => UserStatus::Inactive,
                    "deleted" => UserStatus::Deleted,
                    _ => return Err("Invalid user status".to_string()),
                },
                audit: AuditInfo {
                    created_by: record.created_by,
                    updated_by: record.updated_by,
                    created_at: record.created_at,
                    updated_at: record.updated_at,
                },
            });
        }
        
        Ok(users)
    }
}