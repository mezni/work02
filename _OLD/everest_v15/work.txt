EV Charging Platform DDD Implementation - Summary Prompt
ARC
HITECTURE PROMPT

Domain-Driven Design Microservices Architecture:

    Configurator Service: Manages organizations, stations, users (admins, partners, operators)

    Auth Service: Handles authentication via Keycloak proxy

    User Roles: Super Admin (platform-wide), Partner (org-level), Operator (station-level)

    Data Ownership: Organizations own stations, partners manage orgs, operators manage stations

    Immutable Relationships: User-organization-station relationships fixed at creation

    Audit Trail: Comprehensive logging with soft delete support

Key Constraints:

    Partners belong to one organization, operators to one station

    No station transfers between organizations

    Centralized user management in Configurator service

    Eventual consistency between Configurator and Keycloak

FUNCTIONAL PROMPT

User Management Flow:

    Super Admin creates Partners → Assigns to organizations

    Partners create Stations → Within their organization

    Partners create Operators → Assigns to specific stations

    Soft Delete: User deactivation vs deletion with status tracking

Authorization Rules:

    Super Admin: Full platform access

    Partner: Manage their organization's stations and operators

    Operator: Access only their assigned station

API Structure:

    /api/v1/organizations - Organization management

    /api/v1/organizations/{id}/users/partners - Partner management

    /api/v1/organizations/{id}/users/operators - Operator creation

    /api/v1/users/{id}/deactivate - User lifecycle

TECHNICAL PROMPT

Tech Stack Specifications:

    Language: Rust 1.90

    Framework: Actix-web 4.12.1

    Database: PostgreSQL + SQLx with dynamic queries

    Authentication: Keycloak IDP with JWT claims

    API Docs: OpenAPI with utoipa, Swagger UI at /api/docs

    Configuration: TOML files + environment overrides

    Health Checks: /health (liveness), /ready (readiness with DB/Keycloak connectivity)

    Monitoring: Prometheus metrics + structured JSON logging

    CORS: Allow all origins initially

JWT Claim Structure:
json

{
  "user_id": "configurator-uuid",
  "role": "PARTNER", 
  "organization_id": "org-uuid",
  "station_id": null,
  "user_status": "ACTIVE"
}

Error Standardization:

    Format: { "code": "ERROR_CODE", "message": "Human readable" }

    No timestamps or trace IDs in errors initially

Immediate Implementation Priority:

    Foundation with health checks and configuration

    Domain models with validation

    Actix-web APIs with OpenAPI documentation

    SQLx repository implementations

    Keycloak authentication integration

Deployment: Docker-compose with Postgres + Keycloak
Testing: Comprehensive unit + integration tests
Logging: Default "info" level with JSON structured logs

This summary captures all architectural decisions, functional requirements, and technical specifications for immediate implementation.
give me the steps to implement project
EV Charging Platform - Implementation Steps
PHASE 1: PROJECT FOUNDATION (Week 1)
Day 1: Workspace & Docker Setup

Step 1.1: Create Project Structure
bash

mkdir ev-charging-platform
cd ev-charging-platform
cargo new shared --lib
cargo new configurator-service --bin
cargo new auth-service --bin

Step 1.2: Create Workspace Cargo.toml
toml

[workspace]
members = ["shared", "configurator-service", "auth-service"]

[workspace.dependencies]
actix-web = "4.12.1"
sqlx = { version = "0.7", features = ["postgres", "runtime-actix-native-tls", "uuid", "chrono"] }
serde = { version = "1.0", features = ["derive"] }
uuid = { version = "1.0", features = ["v4", "serde"] }
chrono = { version = "0.4", features = ["serde"] }
thiserror = "1.0"
tracing = "0.1"
tracing-actix-web = "0.7"
utoipa = "3.0"
utoipa-swagger-ui = "3.0"
config = "0.13"

Step 1.3: Create Docker Compose
yaml

# docker-compose.yml
version: '3.8'
services:
  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: ev_charging_configurator
      POSTGRES_USER: ev_charging
      POSTGRES_PASSWORD: password
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

  keycloak:
    image: quay.io/keycloak/keycloak:22.0
    environment:
      KEYCLOAK_ADMIN: admin
      KEYCLOAK_ADMIN_PASSWORD: admin
    ports:
      - "8080:8080"
    command: ["start-dev"]

volumes:
  postgres_data:

Day 2: Configuration & Shared Foundation

Step 2.1: Implement Shared Types & Errors
rust

// shared/src/lib.rs
pub mod types;
pub mod error;
pub mod config;

// shared/src/types.rs
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
pub enum UserRole {
    #[serde(rename = "super_admin")]
    SuperAdmin,
    #[serde(rename = "partner")]
    Partner,
    #[serde(rename = "operator")]
    Operator,
}

// shared/src/error.rs
#[derive(Debug, thiserror::Error)]
pub enum ApiError {
    #[error("Authentication required")]
    Unauthorized,
    // ... other errors
}

Step 2.2: Implement Configuration Management
rust

// shared/src/config.rs
#[derive(Debug, serde::Deserialize, Clone)]
pub struct DatabaseConfig {
    pub host: String,
    pub port: u16,
    // ... all config structs
}

Day 3: Actix-Web Server Setup

Step 3.1: Configurator Service Dependencies
toml

# configurator-service/Cargo.toml
[dependencies]
shared = { path = "../shared" }
actix-web = "4.12.1"
sqlx = { version = "0.7", features = ["postgres", "runtime-actix-native-tls", "uuid", "chrono"] }
utoipa = { version = "3.0", features = ["actix_ext"] }
utoipa-swagger-ui = "3.0"
actix-cors = "0.7"

Step 3.2: Basic Server Setup
rust

// configurator-service/src/main.rs
use actix_web::{web, App, HttpServer};

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    // Initialize logging
    shared::telemetry::init_telemetry();
    
    // Load configuration
    let config = shared::config::load_config().expect("Failed to load configuration");
    
    // Create database connection pool
    let pool = sqlx::postgres::PgPool::connect(&config.database.connection_string())
        .await
        .expect("Failed to connect to database");
    
    HttpServer::new(move || {
        App::new()
            .app_data(web::Data::new(pool.clone()))
            .configure(health::configure)
            .configure(api::configure)
    })
    .bind((config.server.host, config.server.port))?
    .run()
    .await
}

Day 4: Health Checks & Monitoring

Step 4.1: Implement Health Endpoints
rust

// configurator-service/src/health.rs
#[utoipa::path(get, path = "/health", responses((status = 200, description = "Service is healthy")))]
#[get("/health")]
pub async fn health_check() -> impl Responder {
    HttpResponse::Ok().json(serde_json::json!({
        "status": "healthy"
    }))
}

#[get("/ready")]
pub async fn readiness_check(pool: web::Data<PgPool>) -> impl Responder {
    // Check DB connectivity
    match sqlx::query("SELECT 1").execute(pool.get_ref()).await {
        Ok(_) => HttpResponse::Ok().json(serde_json::json!({
            "status": "ready",
            "database": "connected"
        })),
        Err(_) => HttpResponse::ServiceUnavailable().json(serde_json::json!({
            "status": "not_ready", 
            "database": "disconnected"
        }))
    }
}

Day 5: API Structure & OpenAPI

Step 5.1: Configure API Routes
rust

// configurator-service/src/api/mod.rs
pub fn configure(cfg: &mut web::ServiceConfig) {
    cfg.service(
        web::scope("/api")
            .service(web::scope("/v1").configure(v1::configure))
            .service(web::scope("/docs").configure(docs::configure))
    );
}

// configurator-service/src/api/v1/mod.rs
pub fn configure(cfg: &mut web::ServiceConfig) {
    cfg.service(health::health_check)
        .service(health::readiness_check)
        .service(organizations::create_organization);
}

Step 5.2: Setup OpenAPI Documentation
rust

// configurator-service/src/api/docs.rs
use utoipa::OpenApi;
use utoipa_swagger_ui::SwaggerUi;

#[derive(OpenApi)]
#[openapi(paths(health::health_check, health::readiness_check))]
struct ApiDoc;

pub fn configure(cfg: &mut web::ServiceConfig) {
    cfg.service(SwaggerUi::new("/docs/{_:.*}").url("/api-docs/openapi.json", ApiDoc::openapi()));
}

PHASE 2: DOMAIN & DATABASE (Week 2)
Day 6-7: Database Migrations

Step 6.1: Create SQLx Migrations
sql

-- configurator-service/migrations/001_initial.sql
CREATE TABLE organizations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'active',
    created_by UUID NOT NULL,
    updated_by UUID NOT NULL, 
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) UNIQUE NOT NULL,
    display_name VARCHAR(255) NOT NULL,
    role VARCHAR(50) NOT NULL,
    organization_id UUID REFERENCES organizations(id),
    station_id UUID,
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    created_by UUID NOT NULL,
    updated_by UUID NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

Day 8-9: Domain Models

Step 8.1: Implement Domain Models with Validation
rust

// configurator-service/src/domain/user.rs
impl User {
    pub fn new(
        email: String,
        display_name: String,
        role: UserRole,
        organization_id: Option<OrganizationId>,
        station_id: Option<StationId>,
        created_by: UserId,
    ) -> Result<Self, DomainError> {
        // Validate business rules
        Self::validate_creation(&role, organization_id, station_id)?;
        
        Ok(Self {
            id: UserId::new_v4(),
            email,
            display_name,
            role,
            organization_id,
            station_id,
            status: UserStatus::Pending,
            audit: AuditInfo::new(created_by),
        })
    }
}

Day 10: Repository Pattern

Step 10.1: Implement Repository Traits
rust

// configurator-service/src/domain/repositories.rs
#[async_trait]
pub trait UserRepository: Send + Sync {
    async fn find_by_id(&self, id: UserId) -> Result<User, DomainError>;
    async fn save(&self, user: User) -> Result<(), DomainError>;
}

// configurator-service/src/infrastructure/repositories/user_repository.rs
pub struct UserRepositoryImpl {
    pool: PgPool,
}

#[async_trait]
impl UserRepository for UserRepositoryImpl {
    async fn find_by_id(&self, id: UserId) -> Result<User, DomainError> {
        let record = sqlx::query!("SELECT * FROM users WHERE id = $1", id)
            .fetch_one(&self.pool)
            .await?;
            
        User::from_record(record)
    }
}

PHASE 3: API IMPLEMENTATION (Week 3)
Day 11-12: Organization & User APIs

Step 11.1: Implement Organization Endpoints
rust

// configurator-service/src/api/v1/organizations.rs
#[utoipa::path(
    post,
    path = "/organizations",
    request_body = CreateOrganizationRequest,
    responses(
        (status = 201, description = "Organization created"),
        (status = 400, description = "Bad request")
    )
)]
#[post("/organizations")]
pub async fn create_organization(
    auth: AuthExtractor,
    request: web::Json<CreateOrganizationRequest>,
    organization_service: web::Data<OrganizationService>,
) -> Result<HttpResponse, ApiError> {
    // Only super admins can create organizations
    if !auth.is_super_admin() {
        return Err(ApiError::Forbidden);
    }
    
    let command = CreateOrganizationCommand {
        name: request.name.clone(),
        created_by: auth.user_id(),
    };
    
    let organization = organization_service.create_organization(command).await?;
    
    Ok(HttpResponse::Created().json(OrganizationResponse::from_domain(organization)))
}

Day 13-14: Authentication Middleware

Step 13.1: Implement JWT Authentication
rust

// configurator-service/src/infrastructure/auth/middleware.rs
pub struct AuthMiddleware;

impl<S, B> Transform<S, ServiceRequest> for AuthMiddleware
where
    S: Service<ServiceRequest, Response = ServiceResponse<B>, Error = Error>,
{
    type Response = ServiceResponse<B>;
    type Error = Error;
    type Transform = AuthMiddlewareService<S>;
    type InitError = ();
    type Future = Ready<Result<Self::Transform, Self::InitError>>;

    fn new_transform(&self, service: S) -> Self::Future {
        ready(Ok(AuthMiddlewareService { service }))
    }
}

PHASE 4: INTEGRATION & TESTING (Week 4)
Day 15-16: Service Integration

Step 15.1: Implement Service-to-Service Communication
rust

// configurator-service/src/infrastructure/keycloak_client.rs
pub struct KeycloakClient {
    http_client: reqwest::Client,
    base_url: String,
}

impl KeycloakClient {
    pub async fn create_user(&self, user: &User) -> Result<(), KeycloakError> {
        let request = CreateKeycloakUserRequest::from_user(user);
        self.http_client
            .post(&format!("{}/admin/realms/ev-charging/users", self.base_url))
            .json(&request)
            .send()
            .await?;
        Ok(())
    }
}

Day 17-18: Comprehensive Testing

Step 17.1: Implement Unit & Integration Tests
rust

// configurator-service/src/domain/user_test.rs
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_partner_without_organization_fails() {
        let result = User::new(
            "partner@test.com".to_string(),
            "Test Partner".to_string(), 
            UserRole::Partner,
            None, // No organization - should fail
            None,
            UserId::new_v4(),
        );
        
        assert!(result.is_err());
    }
}

Day 19-20: Audit & Monitoring

Step 19.1: Implement Audit Logging
rust

// configurator-service/src/application/audit.rs
pub struct AuditService {
    repository: AuditRepository,
}

impl AuditService {
    pub async fn log_user_creation(&self, user: &User, created_by: UserId) -> Result<(), DomainError> {
        let event = AuditEvent::user_created(user.id, created_by, user.role.clone());
        self.repository.save(event).await
    }
}

EXECUTION CHECKLIST

Week 1 Complete When:

    Docker compose starts Postgres + Keycloak

    Server runs on http://localhost:8080

    Health endpoints respond correctly

    OpenAPI docs available at /api/docs

    Basic configuration loaded

Week 2 Complete When:

    Database migrations run successfully

    Domain models with validation tests pass

    Repository implementations work

    Basic CRUD operations possible

Week 3 Complete When:

    All API endpoints implemented

    JWT authentication working

    Role-based authorization enforced

    OpenAPI documentation complete

Week 4 Complete When:

    Service integration tested

    Comprehensive test suite passing

    Audit logging implemented

    Production-ready monitoring

Ready to start with Day 1 implementation? I can provide the complete code for each step as we progress.