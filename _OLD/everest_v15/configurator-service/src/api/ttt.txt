# EV Charging Platform - Complete Implementation Guide

## Prerequisites
- Rust 1.90+
- Docker & Docker Compose
- PostgreSQL client tools
- Git

---

## PHASE 1: PROJECT FOUNDATION

### Step 1: Create Project Structure

```bash
# Create root directory
mkdir ev-charging-platform
cd ev-charging-platform

# Create workspace members
cargo new shared --lib
cargo new configurator-service --bin
cargo new auth-service --bin

# Initialize git
git init
```

### Step 2: Workspace Configuration

**File: `Cargo.toml`** (root)
```toml
[workspace]
members = ["shared", "configurator-service", "auth-service"]
resolver = "2"

[workspace.dependencies]
actix-web = "4.12.1"
actix-cors = "0.7"
sqlx = { version = "0.8", features = ["postgres", "runtime-tokio-native-tls", "uuid", "chrono", "migrate"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
uuid = { version = "1.0", features = ["v4", "serde"] }
chrono = { version = "0.4", features = ["serde"] }
thiserror = "1.0"
anyhow = "1.0"
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter", "json"] }
tracing-actix-web = "0.7"
tokio = { version = "1.0", features = ["full"] }
config = "0.14"
jsonwebtoken = "9.0"
reqwest = { version = "0.12", features = ["json"] }
async-trait = "0.1"
utoipa = { version = "5.3", features = ["actix_extras", "uuid", "chrono"] }
utoipa-swagger-ui = { version = "8.1", features = ["actix-web"] }
```

### Step 3: Docker Setup

**File: `docker-compose.yml`**
```yaml
version: '3.8'

services:
  postgres:
    image: postgres:15-alpine
    container_name: ev-charging-db
    environment:
      POSTGRES_DB: ev_charging_configurator
      POSTGRES_USER: ev_charging
      POSTGRES_PASSWORD: password123
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ev_charging"]
      interval: 10s
      timeout: 5s
      retries: 5

  keycloak:
    image: quay.io/keycloak/keycloak:23.0
    container_name: ev-charging-keycloak
    environment:
      KEYCLOAK_ADMIN: admin
      KEYCLOAK_ADMIN_PASSWORD: admin
      KC_DB: postgres
      KC_DB_URL: jdbc:postgresql://postgres:5432/keycloak
      KC_DB_USERNAME: ev_charging
      KC_DB_PASSWORD: password123
    ports:
      - "8080:8080"
    command: ["start-dev"]
    depends_on:
      postgres:
        condition: service_healthy

  configurator-service:
    build:
      context: .
      dockerfile: configurator-service/Dockerfile
    container_name: ev-charging-configurator
    ports:
      - "3000:3000"
    environment:
      DATABASE_URL: postgresql://ev_charging:password123@postgres:5432/ev_charging_configurator
      KEYCLOAK_URL: http://keycloak:8080
      RUST_LOG: info
    depends_on:
      - postgres
      - keycloak

volumes:
  postgres_data:
```

### Step 4: Start Infrastructure

```bash
# Start only database and Keycloak first
docker-compose up -d postgres keycloak

# Wait for services to be healthy
docker-compose ps

# Test PostgreSQL connection
psql -h localhost -U ev_charging -d ev_charging_configurator
```

---

## PHASE 2: SHARED LIBRARY

### Step 5: Shared Types & Errors

**File: `shared/Cargo.toml`**
```toml
[package]
name = "shared"
version = "0.1.0"
edition = "2021"

[dependencies]
serde = { workspace = true }
serde_json = { workspace = true }
uuid = { workspace = true }
chrono = { workspace = true }
thiserror = { workspace = true }
actix-web = { workspace = true }
tracing = { workspace = true }
```

**File: `shared/src/lib.rs`**
```rust
pub mod types;
pub mod error;
pub mod config;
pub mod telemetry;

pub use types::*;
pub use error::*;
```

**File: `shared/src/types.rs`**
```rust
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum UserRole {
    SuperAdmin,
    Partner,
    Operator,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum UserStatus {
    Pending,
    Active,
    Inactive,
    Deleted,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum EntityStatus {
    Active,
    Inactive,
    Deleted,
}

// Type aliases for strong typing
pub type UserId = Uuid;
pub type OrganizationId = Uuid;
pub type StationId = Uuid;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JwtClaims {
    pub sub: String,
    pub user_id: UserId,
    pub role: UserRole,
    pub organization_id: Option<OrganizationId>,
    pub station_id: Option<StationId>,
    pub user_status: UserStatus,
    pub exp: usize,
    pub iat: usize,
}
```

**File: `shared/src/error.rs`**
```rust
use actix_web::{error::ResponseError, http::StatusCode, HttpResponse};
use serde::{Deserialize, Serialize};
use std::fmt;

#[derive(Debug, Serialize, Deserialize)]
pub struct ErrorResponse {
    pub code: String,
    pub message: String,
}

#[derive(Debug, thiserror::Error)]
pub enum ApiError {
    #[error("Authentication required")]
    Unauthorized,
    
    #[error("Access forbidden")]
    Forbidden,
    
    #[error("Resource not found: {0}")]
    NotFound(String),
    
    #[error("Bad request: {0}")]
    BadRequest(String),
    
    #[error("Conflict: {0}")]
    Conflict(String),
    
    #[error("Internal server error")]
    InternalServerError,
    
    #[error("Database error: {0}")]
    DatabaseError(String),
    
    #[error("Validation error: {0}")]
    ValidationError(String),
}

impl ResponseError for ApiError {
    fn error_response(&self) -> HttpResponse {
        let (status_code, error_code) = match self {
            ApiError::Unauthorized => (StatusCode::UNAUTHORIZED, "UNAUTHORIZED"),
            ApiError::Forbidden => (StatusCode::FORBIDDEN, "FORBIDDEN"),
            ApiError::NotFound(_) => (StatusCode::NOT_FOUND, "NOT_FOUND"),
            ApiError::BadRequest(_) => (StatusCode::BAD_REQUEST, "BAD_REQUEST"),
            ApiError::Conflict(_) => (StatusCode::CONFLICT, "CONFLICT"),
            ApiError::ValidationError(_) => (StatusCode::BAD_REQUEST, "VALIDATION_ERROR"),
            ApiError::DatabaseError(_) => (StatusCode::INTERNAL_SERVER_ERROR, "DATABASE_ERROR"),
            ApiError::InternalServerError => (StatusCode::INTERNAL_SERVER_ERROR, "INTERNAL_ERROR"),
        };

        let error_response = ErrorResponse {
            code: error_code.to_string(),
            message: self.to_string(),
        };

        HttpResponse::build(status_code).json(error_response)
    }
}

impl From<sqlx::Error> for ApiError {
    fn from(err: sqlx::Error) -> Self {
        tracing::error!("Database error: {:?}", err);
        match err {
            sqlx::Error::RowNotFound => ApiError::NotFound("Resource not found".to_string()),
            _ => ApiError::DatabaseError("Database operation failed".to_string()),
        }
    }
}
```

**File: `shared/src/config.rs`**
```rust
use serde::Deserialize;

#[derive(Debug, Clone, Deserialize)]
pub struct AppConfig {
    pub server: ServerConfig,
    pub database: DatabaseConfig,
    pub keycloak: KeycloakConfig,
    pub logging: LoggingConfig,
}

#[derive(Debug, Clone, Deserialize)]
pub struct ServerConfig {
    pub host: String,
    pub port: u16,
}

#[derive(Debug, Clone, Deserialize)]
pub struct DatabaseConfig {
    pub host: String,
    pub port: u16,
    pub username: String,
    pub password: String,
    pub database: String,
}

impl DatabaseConfig {
    pub fn connection_string(&self) -> String {
        format!(
            "postgresql://{}:{}@{}:{}/{}",
            self.username, self.password, self.host, self.port, self.database
        )
    }
}

#[derive(Debug, Clone, Deserialize)]
pub struct KeycloakConfig {
    pub url: String,
    pub realm: String,
    pub client_id: String,
    pub client_secret: String,
}

#[derive(Debug, Clone, Deserialize)]
pub struct LoggingConfig {
    pub level: String,
    pub format: String,
}

pub fn load_config() -> Result<AppConfig, config::ConfigError> {
    let settings = config::Config::builder()
        .add_source(config::File::with_name("config/default"))
        .add_source(config::Environment::with_prefix("APP").separator("__"))
        .build()?;

    settings.try_deserialize()
}
```

**File: `shared/src/telemetry.rs`**
```rust
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};

pub fn init_telemetry() {
    tracing_subscriber::registry()
        .with(EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("info")))
        .with(tracing_subscriber::fmt::layer().json())
        .init();
}
```

---

## PHASE 3: CONFIGURATOR SERVICE

### Step 6: Service Dependencies

**File: `configurator-service/Cargo.toml`**
```toml
[package]
name = "configurator-service"
version = "0.1.0"
edition = "2021"

[dependencies]
shared = { path = "../shared" }
actix-web = { workspace = true }
actix-cors = { workspace = true }
sqlx = { workspace = true }
serde = { workspace = true }
serde_json = { workspace = true }
uuid = { workspace = true }
chrono = { workspace = true }
thiserror = { workspace = true }
anyhow = { workspace = true }
tracing = { workspace = true }
tracing-subscriber = { workspace = true }
tracing-actix-web = { workspace = true }
tokio = { workspace = true }
config = { workspace = true }
jsonwebtoken = { workspace = true }
reqwest = { workspace = true }
async-trait = { workspace = true }
utoipa = { workspace = true }
utoipa-swagger-ui = { workspace = true }
```

### Step 7: Database Migrations

```bash
# Create migrations directory
mkdir -p configurator-service/migrations
```

**File: `configurator-service/migrations/001_initial_schema.sql`**
```sql
-- Organizations table
CREATE TABLE organizations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL UNIQUE,
    status VARCHAR(50) NOT NULL DEFAULT 'active',
    created_by UUID NOT NULL,
    updated_by UUID NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Stations table
CREATE TABLE stations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    organization_id UUID NOT NULL REFERENCES organizations(id),
    name VARCHAR(255) NOT NULL,
    location VARCHAR(500),
    status VARCHAR(50) NOT NULL DEFAULT 'active',
    created_by UUID NOT NULL,
    updated_by UUID NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(organization_id, name)
);

-- Users table
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) UNIQUE NOT NULL,
    display_name VARCHAR(255) NOT NULL,
    role VARCHAR(50) NOT NULL,
    organization_id UUID REFERENCES organizations(id),
    station_id UUID REFERENCES stations(id),
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    keycloak_id VARCHAR(255),
    created_by UUID NOT NULL,
    updated_by UUID NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- Business rule constraints
    CONSTRAINT partner_must_have_org CHECK (
        role != 'PARTNER' OR organization_id IS NOT NULL
    ),
    CONSTRAINT operator_must_have_station CHECK (
        role != 'OPERATOR' OR (organization_id IS NOT NULL AND station_id IS NOT NULL)
    ),
    CONSTRAINT super_admin_no_org CHECK (
        role != 'SUPER_ADMIN' OR (organization_id IS NULL AND station_id IS NULL)
    )
);

-- Audit log table
CREATE TABLE audit_log (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    entity_type VARCHAR(50) NOT NULL,
    entity_id UUID NOT NULL,
    action VARCHAR(50) NOT NULL,
    actor_id UUID NOT NULL,
    changes JSONB,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_role ON users(role);
CREATE INDEX idx_users_organization ON users(organization_id);
CREATE INDEX idx_users_station ON users(station_id);
CREATE INDEX idx_stations_organization ON stations(organization_id);
CREATE INDEX idx_audit_entity ON audit_log(entity_type, entity_id);
CREATE INDEX idx_audit_actor ON audit_log(actor_id);
```

### Step 8: Run Migrations

```bash
# Install sqlx-cli
cargo install sqlx-cli --no-default-features --features postgres

# Set database URL
export DATABASE_URL=postgresql://ev_charging:password123@localhost:5432/ev_charging_configurator

# Run migrations
cd configurator-service
sqlx migrate run
```

---

## Quick Start Commands

```bash
# 1. Start infrastructure
docker-compose up -d postgres keycloak

# 2. Run migrations
cd configurator-service && sqlx migrate run

# 3. Build and run service
cargo run --bin configurator-service

# 4. Test endpoints
curl http://localhost:3000/health
curl http://localhost:3000/api/docs

# 5. View logs
docker-compose logs -f configurator-service
```

---

## Next Steps

Continue with:
1. Domain models implementation
2. Repository pattern
3. API endpoints
4. Authentication middleware
5. Service integration
6. Testing

Each phase builds on the previous foundation. The complete implementation will take approximately 4 weeks following the provided schedule.