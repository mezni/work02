Auth Service Recreation Prompt
Project Overview

Create a Rust-based authentication and authorization microservice with the following architecture

and features:
Core Requirements
1. Architecture Pattern

    Clean Architecture with clear separation of concerns

    CQRS (Command Query Responsibility Segregation) pattern

    Domain-Driven Design principles

    Modular structure with clear boundaries

2. Technology Stack

    Framework: Actix-web 4.x

    Database: PostgreSQL with SQLx

    Authentication: JWT + Keycloak integration

    Documentation: Utoipa for OpenAPI/Swagger

    Validation: Validator crate

    Logging: Tracing and tracing-subscriber

    Error Handling: Thiserror with custom error types

    Testing: Comprehensive unit and integration tests

Project Structure
text

auth-service/
├── src/
│   ├── main.rs                 # Application entry point
│   ├── lib.rs                  # Library exports and prelude
│   ├── domain/                 # Core business logic
│   │   ├── entities/           # Domain entities (User, Company, AuditLog)
│   │   ├── value_objects/      # Value objects (Email, Password)
│   │   ├── enums/              # Enums (UserRole, AuditAction)
│   │   ├── repositories/       # Repository traits
│   │   └── errors.rs           # Domain errors
│   ├── application/            # Application business rules
│   │   ├── commands/           # Command definitions
│   │   ├── queries/            # Query definitions
│   │   ├── dto/                # Data Transfer Objects
│   │   ├── command_handlers.rs # Command handlers
│   │   ├── queries_handlers.rs # Query handlers
│   │   ├── services/           # Application services
│   │   └── errors.rs           # Application errors
│   ├── infrastructure/         # External concerns
│   │   ├── config/             # Configuration management
│   │   ├── database/           # Database implementations
│   │   ├── auth/               # Authentication (JWT, Keycloak)
│   │   ├── audit/              # Audit logging
│   │   └── errors.rs           # Infrastructure errors
│   └── interfaces/             # External interfaces
│       ├── controllers/        # HTTP controllers
│       ├── routes/             # Route configuration
│       ├── openapi/            # OpenAPI documentation
│       └── errors.rs           # Interface errors
├── tests/                      # Test suites
│   ├── integration/            # Integration tests
│   └── unit/                   # Unit tests
├── config/                     # Configuration files
│   ├── default.toml
│   ├── development.toml
│   └── production.toml
├── migrations/                 # Database migrations
└── Cargo.toml

Key Features to Implement
1. Authentication & Authorization

    User registration with email verification

    JWT token generation and validation

    Keycloak integration for user management

    Role-based access control (Admin, Partner, Operator, User)

    Password reset functionality

    Token refresh mechanism

2. User Management

    CRUD operations for users

    Role management

    Company assignment

    Profile management

    Email verification

3. Company Management

    Company CRUD operations

    User-company associations

    Company-specific permissions

4. Audit Logging

    Comprehensive audit trail

    User action tracking

    Security event logging

    Audit log search and export

5. API Features

    RESTful API design

    OpenAPI 3.0 documentation

    Request validation

    Pagination support

    Error handling with proper HTTP status codes

Implementation Steps
Phase 1: Foundation

    Set up project structure and dependencies

    Implement configuration management

    Create database models and migrations

    Set up basic error handling

Phase 2: Core Domain

    Implement domain entities and value objects

    Create repository traits

    Implement domain services

    Add domain validation rules

Phase 3: Application Layer

    Implement CQRS pattern with commands and queries

    Create command and query handlers

    Implement DTOs for API contracts

    Add application services

Phase 4: Infrastructure

    Implement PostgreSQL repositories

    Add JWT authentication service

    Integrate Keycloak client

    Implement audit logging system

Phase 5: Interfaces

    Create Actix-web controllers

    Implement route configuration

    Add OpenAPI documentation

    Set up middleware (authentication, logging)

Phase 6: Testing & Documentation

    Write comprehensive unit tests

    Create integration tests

    Add API documentation examples

    Set up health checks and monitoring

Technical Specifications
Database Schema

    Users table with role and company associations

    Companies table with ownership information

    Audit logs table for tracking all actions

    Proper indexes and constraints

API Endpoints
text

POST   /api/v1/auth/register
POST   /api/v1/auth/login
POST   /api/v1/auth/refresh
POST   /api/v1/auth/forgot-password
POST   /api/v1/auth/reset-password
POST   /api/v1/auth/change-password
GET    /api/v1/auth/validate-token

GET    /api/v1/users
POST   /api/v1/users
GET    /api/v1/users/{id}
PUT    /api/v1/users/{id}
DELETE /api/v1/users/{id}
PUT    /api/v1/users/{id}/role
PUT    /api/v1/users/{id}/company

GET    /api/v1/companies
POST   /api/v1/companies
GET    /api/v1/companies/{id}
PUT    /api/v1/companies/{id}
DELETE /api/v1/companies/{id}
GET    /api/v1/companies/{id}/users

GET    /api/v1/audit/logs
GET    /api/v1/audit/logs/export
GET    /api/v1/audit/statistics

GET    /health
GET    /metrics
GET    /swagger-ui/

Configuration

    Environment-based configuration

    Database connection settings

    JWT secret and expiration

    Keycloak server settings

    Audit log retention policies

Testing Strategy

    Unit tests for domain logic and value objects

    Integration tests for API endpoints

    Repository tests with test database

    Mock external services (Keycloak)

    Load testing for critical endpoints

Deployment Considerations

    Docker containerization

    Database migration strategy

    Health check endpoints

    Logging and monitoring

    Security best practices

Success Criteria

    All tests passing

    OpenAPI documentation complete

    API endpoints functional

    Proper error handling

    Security measures implemented

    Performance benchmarks met

This prompt provides a comprehensive blueprint for recreating the auth service with proper architecture, clear implementation steps, and production-ready features.