drwxrwxr-x 2 dali dali 4096 Dec  4 21:19 auth-service
drwxrwxr-x 2 dali dali 4096 Dec  4 21:19 admin-service
drwxrwxr-x 2 dali dali 4096 Dec  4 21:19 locate-service


curl http://127.0.0.1:5080/realms/myrealm/protocol/openid-connect/certs



use actix_web::{
    web, App, HttpServer, Responder, HttpResponse, Result as ActixResult, 
    http::StatusCode, HttpRequest
};
use actix_web_httpauth::extractors::bearer::{BearerAuth, BearerAuthError};
use jsonwebtoken::{
    decode, decode_header, jwk::{self, JwkSet}, Algorithm, DecodingKey, Validation
};
use std::{sync::Arc, time::Duration};
use serde::{Deserialize, Serialize};

// Environment variable key for Keycloak JWKS URL
const KEYCLOAK_JWKS_URL_ENV: &str = "KEYCLOAK_JWKS_URL";

// --- 1. Keycloak Configuration State ---
// This holds the application state, specifically the fetched Keycloak JWKS.
#[derive(Clone)]
pub struct AppState {
    jwks: Arc<tokio::sync::RwLock<JwkSet>>,
    jwks_url: String,
}

// --- 2. JWT Claims Struct ---
// Define the structure of the payload (claims) inside the JWT.
#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct Claims {
    pub sub: String, // Subject (user ID)
    pub exp: usize, // Expiration time
    pub iat: usize, // Issued at
    pub preferred_username: String,
    // Add other claims your Keycloak realm includes
}


// --- 3. JWKS Fetching Logic (Periodically) ---

/// Background task to periodically fetch and update the JWKS from Keycloak.
async fn fetch_and_update_jwks(state: web::Data<AppState>) {
    let client = reqwest::Client::new();
    loop {
        tracing::info!("Attempting to fetch and update JWKS from: {}", state.jwks_url);
        match client.get(&state.jwks_url).send().await {
            Ok(res) => match res.json::<JwkSet>().await {
                Ok(jwks_set) => {
                    *state.jwks.write().await = jwks_set;
                    tracing::info!("Successfully updated JWKS.");
                }
                Err(e) => {
                    tracing::error!("Failed to parse JWKS JSON: {:?}", e);
                }
            },
            Err(e) => {
                tracing::error!("Failed to fetch JWKS from Keycloak: {:?}", e);
            }
        }
        // Wait 5 minutes before trying again
        tokio::time::sleep(Duration::from_secs(300)).await;
    }
}

// --- 4. Bearer Token Validator (The Core Authentication Logic) ---

/// This function is called by the BearerAuth extractor to validate the token.
pub async fn validator(
    req: HttpRequest,
    auth: BearerAuth,
) -> ActixResult<Claims, BearerAuthError> {
    let app_state = req.app_data::<web::Data<AppState>>().expect("AppState not configured");
    let token = auth.token();
    let jwks_set = app_state.jwks.read().await;

    // 1. Decode header to find the Key ID (kid)
    let header = decode_header(token).map_err(|_| BearerAuthError::from(()))?;

    let kid = header.kid.ok_or_else(BearerAuthError::from)?;

    // 2. Find the matching JWK
    let jwk = jwks_set.find(&kid).ok_or_else(|| {
        tracing::warn!("No matching JWK found for kid: {}", kid);
        BearerAuthError::from(())
    })?;

    // 3. Create a decoding key from the JWK
    let decoding_key = DecodingKey::from_jwk(&jwk).map_err(|e| {
        tracing::error!("Failed to create decoding key: {:?}", e);
        BearerAuthError::from(())
    })?;

    // 4. Validate and decode the token
    let mut validation = Validation::new(Algorithm::RS256); // Keycloak typically uses RS256
    validation.set_required_spec_claims(&["exp", "sub", "iss"]);
    
    // Note: You may want to set issuer and audience here:
    // validation.set_issuer(&["http://keycloak:8080/realms/your-realm"]);

    match decode::<Claims>(token, &decoding_key, &validation) {
        Ok(token_data) => {
            tracing::info!("Token validated for user: {}", token_data.claims.preferred_username);
            Ok(token_data.claims)
        }
        Err(e) => {
            tracing::warn!("Token validation failed: {:?}", e);
            Err(BearerAuthError::from(()))
        }
    }
}


// --- 5. Protected Endpoint Handler ---

/// This handler receives the validated Claims directly from the Actix-web-httpauth extractor.
#[actix_web::get("/api/protected")]
async fn protected_data_handler(claims: Claims) -> ActixResult<impl Responder> {
    let response_data = serde_json::json!({
        "message": "Welcome to the protected resource!",
        "user_id": claims.sub,
        "username": claims.preferred_username,
        "source_service": "resource-service (Actix-web)",
    });

    Ok(HttpResponse::Ok().json(response_data))
}

// --- 6. Main Function ---

#[tokio::main]
async fn main() -> std::io::Result<()> {
    tracing_subscriber::fmt::init();

    // 1. Load Keycloak JWKS URL from environment
    let jwks_url = std::env::var(KEYCLOAK_JWKS_URL_ENV)
        .expect("KEYCLOAK_JWKS_URL environment variable must be set.");

    // 2. Initialize the application state
    let app_state = web::Data::new(AppState {
        jwks: Arc::new(tokio::sync::RwLock::new(JwkSet { keys: vec![] })),
        jwks_url,
    });
    
    // Create a clone of the state for the background task
    let background_state = app_state.clone();

    // 3. Start the background task to fetch and update JWKS periodically
    tokio::spawn(fetch_and_update_jwks(background_state));

    // Wait briefly for the initial fetch to complete (or fail) before starting the server
    tokio::time::sleep(Duration::from_secs(5)).await;
    
    // 4. Start the Actix-web server
    tracing::info!("Resource Service listening on 0.0.0.0:8080");

    HttpServer::new(move || {
        App::new()
            .app_data(app_state.clone()) // Attach the shared application state
            // Define the protected route, protected by the BearerAuth extractor
            .service(
                web::scope("/")
                    .wrap(actix_web::middleware::Logger::default()) // Logging
                    .service(protected_data_handler) // This route uses the Claims extractor
            )
            // Health check route (unprotected)
            .route("/health", web::get().to(|| async { HttpResponse::Ok().body("OK") }))
    })
    .bind(("0.0.0.0", 8080))?
    .run()
    .await
}


























use actix_web::{web, App, HttpResponse, HttpServer, Responder, post, get};
use serde::{Deserialize, Serialize};
use jsonwebtoken::{decode, DecodingKey, Validation, Algorithm, TokenData};
use chrono::Utc;
use std::collections::HashMap;

#[derive(Serialize)]
struct HealthResponse {
status: String,
timestamp: String,
service: String,
version: String,
}

#[derive(Deserialize)]
struct DecodeTokenRequest {
token: String,
}

#[derive(Serialize)]
struct DecodeTokenResponse {
valid: bool,
claims: Option<HashMap<String, serde_json::Value>>,
message: Option<String>,
}

// ------------------ Endpoints ------------------

#[get("/api/v1/health")]
async fn health() -> impl Responder {
HttpResponse::Ok().json(HealthResponse {
status: "UP".to_string(),
timestamp: Utc::now().to_rfc3339(),
service: "authentication-service".to_string(),
version: "1.0.0".to_string(),
})
}

/// Decode JWT issued by Keycloak
#[post("/api/v1/decode-token")]
async fn decode_token(body: web::Json<DecodeTokenRequest>, key: web::Data<String>) -> impl Responder {
let mut validation = Validation::new(Algorithm::RS256);
validation.validate_exp = true;


match decode::<HashMap<String, serde_json::Value>>(
    &body.token,
    &DecodingKey::from_rsa_pem(key.as_bytes()).unwrap(),
    &validation,
) {
    Ok(TokenData { claims, .. }) => HttpResponse::Ok().json(DecodeTokenResponse {
        valid: true,
        claims: Some(claims),
        message: None,
    }),
    Err(e) => HttpResponse::Unauthorized().json(DecodeTokenResponse {
        valid: false,
        claims: None,
        message: Some(format!("Invalid token: {}", e)),
    }),
}


}

// ------------------ Main ------------------

#[actix_web::main]
async fn main() -> std::io::Result<()> {
// Keycloak public key directly in main
let keycloak_public_key = r#"-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAnExamplePublicKeyHere
-----END PUBLIC KEY-----"#.to_string();


println!("ðŸš€ Authentication Service running at http://localhost:3000");

HttpServer::new(move || {
    App::new()
        .app_data(web::Data::new(keycloak_public_key.clone()))
        .service(health)
        .service(decode_token)
})
.bind(("127.0.0.1", 3001))?
.run()
.await


}






ev-platform/
â”‚
â”œâ”€ auth-service/
â”‚  â”œâ”€ src/
â”‚  â”‚  â”œâ”€ main.rs
â”‚  â”‚  â”œâ”€ lib.rs
â”‚  â”‚  â”œâ”€ routes.rs
â”‚  â”‚  â”œâ”€ handlers.rs
â”‚  â”‚  â”œâ”€ models.rs
â”‚  â”‚  â”œâ”€ repositories.rs
â”‚  â”‚  â”œâ”€ services.rs
â”‚  â”‚  â””â”€ errors.rs
â”‚  â”œâ”€ Cargo.toml
â”‚  â””â”€ Dockerfile
â”‚
â”œâ”€ station-service/
â”‚  â”œâ”€ src/
â”‚  â”‚  â”œâ”€ main.rs
â”‚  â”‚  â”œâ”€ lib.rs
â”‚  â”‚  â”œâ”€ routes.rs
â”‚  â”‚  â”œâ”€ handlers.rs
â”‚  â”‚  â”œâ”€ models.rs
â”‚  â”‚  â”œâ”€ repositories.rs
â”‚  â”‚  â”œâ”€ services.rs
â”‚  â”‚  â””â”€ errors.rs
â”‚  â”œâ”€ Cargo.toml
â”‚  â””â”€ Dockerfile
â”‚
â”œâ”€ network-service/
â”‚  â”œâ”€ src/
â”‚  â”‚  â”œâ”€ main.rs
â”‚  â”‚  â”œâ”€ lib.rs
â”‚  â”‚  â”œâ”€ routes.rs
â”‚  â”‚  â”œâ”€ handlers.rs
â”‚  â”‚  â”œâ”€ models.rs
â”‚  â”‚  â”œâ”€ repositories.rs
â”‚  â”‚  â”œâ”€ services.rs
â”‚  â”‚  â””â”€ errors.rs
â”‚  â”œâ”€ Cargo.toml
â”‚  â””â”€ Dockerfile
â”‚
â”œâ”€ deployments/
â”‚  â”œâ”€ docker-compose.yml
â”‚  â”œâ”€ networks.env
â”‚  â”œâ”€ stations.env
â”‚  â””â”€ auth.env
â”‚
â”œâ”€ databases/
â”‚  â”œâ”€ auth.sql
â”‚  â”œâ”€ network.sql
â”‚  â””â”€ station.sql
â”‚
â””â”€ README.md



version: '3.9'

services:

  # ========================
  # Auth Service + DB
  # ========================
  auth-service:
    build: ./auth-service
    env_file: ./deployments/auth.env
    ports:
      - "8001:8001"
    depends_on:
      - auth-db
    networks:
      - ev-network

  auth-db:
    image: postgres:15
    container_name: auth-db
    environment:
      POSTGRES_DB: auth
      POSTGRES_USER: auth_user
      POSTGRES_PASSWORD: secret
    ports:
      - "5432:5432"
    volumes:
      - auth-data:/var/lib/postgresql/data
    networks:
      - ev-network

  # ========================
  # Station Service + DB
  # ========================
  station-service:
    build: ./station-service
    env_file: ./deployments/stations.env
    ports:
      - "8002:8002"
    depends_on:
      - station-db
    networks:
      - ev-network

  station-db:
    image: postgres:15
    container_name: station-db
    environment:
      POSTGRES_DB: station
      POSTGRES_USER: station_user
      POSTGRES_PASSWORD: secret
    ports:
      - "5433:5432"
    volumes:
      - station-data:/var/lib/postgresql/data
    networks:
      - ev-network

  # ========================
  # Network Service + DB
  # ========================
  network-service:
    build: ./network-service
    env_file: ./deployments/networks.env
    ports:
      - "8003:8003"
    depends_on:
      - network-db
    networks:
      - ev-network

  network-db:
    image: postgres:15
    container_name: network-db
    environment:
      POSTGRES_DB: network
      POSTGRES_USER: network_user
      POSTGRES_PASSWORD: secret
    ports:
      - "8004:5432"
    volumes:
      - network-data:/var/lib/postgresql/data
    networks:
      - ev-network

# ========================
# Volumes
# ========================
volumes:
  auth-data:
  station-data:
  network-data:

# ========================
# Networks
# ========================
networks:
  ev-network:
    driver: bridge
